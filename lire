#!/usr/bin/env python3

import argparse
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup
import curses

def extract_text_by_chapter(book):
    chapters = []
    for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
        content = item.get_body_content()
        soup = BeautifulSoup(content, 'html.parser')
        chapter_text = soup.get_text()
        chapters.append(chapter_text)
    return chapters

def wrap_text(text, width):
    wrapped_lines = []
    lines = text.splitlines()
    current_paragraph = []
    for line in lines:
        if line.strip() and not line.startswith(' '):
            if current_paragraph:
                wrapped_lines.extend(wrap_paragraph(current_paragraph, width))
                wrapped_lines.append("")
                current_paragraph = []
            current_paragraph.append(line.strip())
        else:
            current_paragraph.append(line.strip())
    if current_paragraph:
        wrapped_lines.extend(wrap_paragraph(current_paragraph, width))
    return wrapped_lines

def wrap_paragraph(paragraph_lines, width):
    wrapped = []
    current_line = ""
    for line in paragraph_lines:
        words = line.split()
        for word in words:
            if len(current_line) + len(word) + (1 if current_line else 0) > width:
                wrapped.append(current_line)
                current_line = word
            else:
                if current_line:
                    current_line += " "
                current_line += word
        if current_line: 
            wrapped.append(current_line)
            current_line = ""
    return wrapped

def display_chapter(stdscr, chapter, start_line, height, chapter_number, total_chapters):
    lines = wrap_text(chapter, curses.COLS)
    max_lines = len(lines)
    visible_lines = height - 2
    for i in range(start_line, min(start_line + visible_lines, max_lines)):
        stdscr.addstr(i - start_line, 0, lines[i])
    footer = f"Page {chapter_number + 1} of {total_chapters} | Showing lines {start_line + 1} to {min(start_line + visible_lines, max_lines)} of {max_lines}"
    stdscr.addstr(height - 1, curses.COLS - len(footer) - 1, footer)

def display_chapters(stdscr, chapters):
    curses.curs_set(0)

    current_chapter = 0
    start_line = 0
    height, _ = stdscr.getmaxyx()
    total_chapters = len(chapters)

    while current_chapter < total_chapters:
        stdscr.clear()
        chapter = chapters[current_chapter]
        display_chapter(stdscr, chapter, start_line, height, current_chapter, total_chapters)
        stdscr.refresh()
        visible_lines = height - 2
        key = stdscr.getch()
        if key == curses.KEY_DOWN or key == ord('j'):
            if start_line < len(wrap_text(chapter, curses.COLS)) - visible_lines:
                start_line += 1
        elif key == curses.KEY_UP or key == ord('k'):
            if start_line > 0:
                start_line -= 1
        elif key == curses.KEY_RIGHT or key == ord('l'):
            if current_chapter < total_chapters - 1:
                current_chapter += 1
                start_line = 0
        elif key == curses.KEY_LEFT or key == ord('h'):
            if current_chapter > 0:
                current_chapter -= 1
                start_line = 0
        elif key == ord(' '):
            if start_line < len(wrap_text(chapter, curses.COLS)) - visible_lines:
                start_line += visible_lines
        elif key == curses.KEY_BACKSPACE:
            if start_line >= visible_lines:
                start_line -= visible_lines
            elif start_line - visible_lines <= 0:
                start_line = 0
        elif key == ord('q'):
            break

def main():
    parser = argparse.ArgumentParser(description='EPUB TUI Reader.')
    parser.add_argument('input_path', type=str, help='Path to EPUB file')
    parser.add_argument('-o', '--output', type=str, help='Output directory for chapter text files')
    args = parser.parse_args()
    book = epub.read_epub(args.input_path)
    chapters = extract_text_by_chapter(book)

    def curses_main(stdscr):
        display_chapters(stdscr, chapters)
    curses.wrapper(curses_main)

if __name__ == "__main__":
    main()
